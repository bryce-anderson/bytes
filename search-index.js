var searchIndex = {};
searchIndex['bytes'] = {"items":[[0,"","bytes","",null,null],[4,"BufError","","",null,null],[13,"Underflow","","",0,null],[13,"Overflow","","",0,null],[0,"alloc","","",null,null],[3,"Heap","bytes::alloc","",null,null],[3,"MemRef","","",null,null],[3,"Mem","","Memory allocated by an Allocator must be prefixed with Mem",null,null],[5,"heap","","",null,{"inputs":[{"name":"usize"}],"output":{"name":"memref"}}],[11,"allocate","","",1,{"inputs":[{"name":"heap"},{"name":"usize"}],"output":{"name":"memref"}}],[11,"deallocate","","",1,null],[11,"allocate","","",1,{"inputs":[{"name":"heap"},{"name":"usize"}],"output":{"name":"memref"}}],[11,"deallocate","","",1,null],[8,"Allocator","","Allocates memory to be used by Bufs or Bytes. Allows allocating memory\nusing alternate stratgies than the default Rust heap allocator. Also does\nnot require that allocations are continuous in memory.",null,null],[10,"allocate","","Allocate memory. May or may not be contiguous.",2,{"inputs":[{"name":"allocator"},{"name":"usize"}],"output":{"name":"memref"}}],[10,"deallocate","","Deallocate a chunk of memory",2,null],[11,"new","","",3,null],[11,"none","","",3,{"inputs":[{"name":"memref"}],"output":{"name":"memref"}}],[11,"is_none","","",3,{"inputs":[{"name":"memref"}],"output":{"name":"bool"}}],[11,"ptr","","",3,null],[11,"bytes","","",3,null],[11,"bytes_mut","","",3,null],[11,"clone","","",3,{"inputs":[{"name":"memref"}],"output":{"name":"memref"}}],[11,"drop","","",3,{"inputs":[{"name":"memref"}],"output":null}],[11,"new","","",4,null],[11,"remaining","alloc::boxed","",5,{"inputs":[{"name":"box"}],"output":{"name":"usize"}}],[11,"bytes","","",5,null],[11,"advance","","",5,{"inputs":[{"name":"box"},{"name":"usize"}],"output":null}],[11,"read_slice","","",5,null],[11,"fmt","","",5,{"inputs":[{"name":"box"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"remaining","std::io::cursor","",6,{"inputs":[{"name":"cursor"}],"output":{"name":"usize"}}],[11,"bytes","","",6,null],[11,"advance","","",6,{"inputs":[{"name":"cursor"},{"name":"usize"}],"output":null}],[11,"remaining","collections::vec","",7,{"inputs":[{"name":"vec"}],"output":{"name":"usize"}}],[11,"advance","","",7,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":null}],[11,"mut_bytes","","",7,null],[11,"remaining","std::io::cursor","",6,{"inputs":[{"name":"cursor"}],"output":{"name":"usize"}}],[11,"bytes","","",6,null],[11,"advance","","",6,{"inputs":[{"name":"cursor"},{"name":"usize"}],"output":null}],[11,"read","alloc::boxed","",5,null],[0,"traits","bytes","All traits are re-exported here to allow glob imports.",null,null],[8,"Buf","","A trait for values that provide sequential read access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",8,{"inputs":[{"name":"buf"}],"output":{"name":"usize"}}],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",8,null],[10,"advance","","Advance the internal cursor of the Buf",8,{"inputs":[{"name":"buf"},{"name":"usize"}],"output":null}],[11,"has_remaining","","Returns true if there are any more bytes to consume",8,{"inputs":[{"name":"buf"}],"output":{"name":"bool"}}],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",8,null],[11,"read_byte","","Read a single byte from the `Buf`",8,{"inputs":[{"name":"buf"}],"output":{"name":"option"}}],[8,"BufExt","","An extension trait providing extra functions applicable to all `Buf` values.",null,null],[10,"read","","Read bytes from this Buf into the given sink and advance the cursor by\nthe number of bytes read.",9,{"inputs":[{"name":"bufext"},{"name":"s"}],"output":{"name":"result"}}],[8,"MutBuf","","A trait for values that provide sequential write access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be written to the MutBuf",10,{"inputs":[{"name":"mutbuf"}],"output":{"name":"usize"}}],[10,"advance","","Advance the internal cursor of the MutBuf",10,{"inputs":[{"name":"mutbuf"},{"name":"usize"}],"output":null}],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",10,{"inputs":[{"name":"mutbuf"}],"output":{"name":"bool"}}],[10,"mut_bytes","","Returns a mutable slice starting at the current MutBuf position and of\nlength between 0 and `MutBuf::remaining()`.",10,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",10,null],[11,"write_byte","","Write a single byte to the `MuBuf`",10,{"inputs":[{"name":"mutbuf"},{"name":"u8"}],"output":{"name":"bool"}}],[8,"MutBufExt","","An extension trait providing extra functions applicable to all `MutBuf` values.",null,null],[10,"write","","Write bytes from the given source into the current `MutBuf` and advance\nthe cursor by the number of bytes written.",11,{"inputs":[{"name":"mutbufext"},{"name":"s"}],"output":{"name":"result"}}],[8,"Source","","A value that writes bytes from itself into a `MutBuf`.",null,null],[16,"Error","","",12,null],[10,"fill","","",12,{"inputs":[{"name":"source"},{"name":"b"}],"output":{"name":"result"}}],[8,"Sink","","A value that reads bytes from a Buf into itself",null,null],[16,"Error","","",13,null],[10,"sink","","",13,{"inputs":[{"name":"sink"},{"name":"b"}],"output":{"name":"result"}}],[8,"ByteStr","","An immutable sequence of bytes. Operations will not mutate the original\nvalue. Since only immutable access is permitted, operations do not require\ncopying (though, sometimes copying will happen as an optimization).",null,null],[16,"Buf","","",14,null],[10,"buf","","Returns a read-only `Buf` for accessing the byte contents of the\n`ByteStr`.",14,{"inputs":[{"name":"bytestr"}],"output":{"name":"buf"}}],[10,"concat","","Returns a new `Bytes` value representing the concatenation of `self`\nwith the given `Bytes`.",14,{"inputs":[{"name":"bytestr"},{"name":"b"}],"output":{"name":"bytes"}}],[10,"len","","Returns the number of bytes in the ByteStr",14,{"inputs":[{"name":"bytestr"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if the length of the `ByteStr` is 0",14,{"inputs":[{"name":"bytestr"}],"output":{"name":"bool"}}],[10,"slice","","Returns a new ByteStr value containing the byte range between `begin`\n(inclusive) and `end` (exclusive)",14,{"inputs":[{"name":"bytestr"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bytes"}}],[11,"slice_from","","Returns a new ByteStr value containing the byte range starting from\n`begin` (inclusive) to the end of the byte str.",14,{"inputs":[{"name":"bytestr"},{"name":"usize"}],"output":{"name":"bytes"}}],[11,"slice_to","","Returns a new ByteStr value containing the byte range from the start up\nto `end` (exclusive).",14,{"inputs":[{"name":"bytestr"},{"name":"usize"}],"output":{"name":"bytes"}}],[11,"split_at","","Divides the value into two `Bytes` at the given index.",14,null],[8,"ToBytes","","",null,null],[10,"to_bytes","","Consumes the value and returns a `Bytes` instance containing\nidentical bytes",15,{"inputs":[{"name":"tobytes"}],"output":{"name":"bytes"}}],[11,"fmt","","",0,{"inputs":[{"name":"buferror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"buferror"}],"output":{"name":"buferror"}}],[11,"has_remaining","","Returns true if there are any more bytes to consume",8,null],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",8,null],[11,"read_byte","","Read a single byte from the `Buf`",8,null],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",10,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",10,null],[11,"write_byte","","Write a single byte to the `MuBuf`",10,null],[11,"is_empty","","Returns true if the length of the `ByteStr` is 0",14,null],[11,"slice_from","","Returns a new ByteStr value containing the byte range starting from\n`begin` (inclusive) to the end of the byte str.",14,null],[11,"slice_to","","Returns a new ByteStr value containing the byte range from the start up\nto `end` (exclusive).",14,null],[11,"split_at","","Divides the value into two `Bytes` at the given index.",14,null]],"paths":[[4,"BufError"],[3,"Heap"],[8,"Allocator"],[3,"MemRef"],[3,"Mem"],[3,"Box"],[3,"Cursor"],[3,"Vec"],[8,"Buf"],[8,"BufExt"],[8,"MutBuf"],[8,"MutBufExt"],[8,"Source"],[8,"Sink"],[8,"ByteStr"],[8,"ToBytes"]]};
initSearch(searchIndex);
